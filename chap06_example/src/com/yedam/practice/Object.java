package com.yedam.practice;

public class Object {
	public static void main(String[] args) {

	//객체 -> 자신의 속성을 가지고있으며 식별 가능한 것
	//객체의 속성 -> 필드 , 객체의  동작 -> 메소드
	//객체의 상호작용 수단 -> 메소드 호출
	
	  //<메소드 호출>
	//리턴값 = 전자계산기객체.메소드(매개값1, 매개값2,,,);
	//-객체에 .연산자 붙이고 메소드이름 기술
	//- . : 필드와 메소드에 접근할때 사용
	//-매개값: 메소드를 실행하기위해 필요한 데이터값
	//-리턴값: 메소드가 실행되고 난 후 호출한 곳으로 돌려주는 값
	
	
	//int result = Calculator.add(10, 20);
	//전자계산기 객체에 연산자.을 사용하여 add라는 메소드를 호출했고, 메소드 실행을위해 매개값 10,20을 주어서 호출 후 정수형식을 가진 reseult라는 변수에 저장
	
	
	
		//<클래스>
	//메모리에서 사용할 객체를 만드려면 설계도 필요 -> 이 작업이 클래스 생성
	//*클래스에는 객체 생성을 위한 필드와 메소드가 정의되어 있음
	//*인스턴스->클래스로부터 만들어진 객체
		
		//<main 메소드 없는 클래스 생성>
	//*클래스 선언
	//1.  클래스파일 만들기 : 사용하고자하는 객체 구상 후 -> 이름 짓기 -> 클래스의 이름으로 설정
	//2. 소스파일 생성하기 위해 클래스 선언 : ex) public class Student{}
	//*주의* 소스파일은 선언을 담고있는 저장단위, 클래스 자체로 쓰이는게 아님
	
	//*클래스로부터 객체 생성
	//new 연산자 사용 -> 클래스로부터 객체를 생성시키는 연산자 -> new 클래스이름();
	//생성자 -> '클래스()'의 형태
	//new 연산자로 생성된 객체는 힙에 저장 -> 힙영역에서 객체 생성 후 객체의 번지 리턴값으로 줌 -> 이주소를 참조타입 클래스 변수에 저장해두면 변수통해서 계속 사용가능
	//ex) 클래스 변수; -> 변수 = new 클래스(); => 클래스변수=new 클래스();
	
	
	//Student 클래스 선언 -> Student 클래스에 선언(라이브러리 클래스)
//
		//클래스의 구성멤버->객체가 가져야할 구성멤버
	//필드 : 객체 고유의 데이터가 저장되는 곳 -> ex) int fieldname; 
	//변수와 비슷해보이지만 변수는 생성자와 메소드내에서 실행되고 종료되면 소멸/ 필드는 생성자와 메소드 전체에 사용되며 소명되지않음
	//생성자 : new 연산자로 호출되는 특별한 {} -> 객체 생성시 초기화역할
	//메소드와 비슷하게 생겼지만, 클래스 이름으로 되어있고 리턴타입없음 (OOOO=o ->이런형태가 아님) -> ex)ClassName(){}
	//메소드 : 객체 동작하게 하는 실행블록{}안의 코드들이 일괄 실행 -> ex)void methodName(){}
	//객체간 데이터전달수단이므로, 호출한 외부로부터 매개값을 받아 실행되기도하고, 실행후 결과값을 호출한곳으로 돌려주기도한다.
	
	
	}
	
}
