package practice0803_noname_implements;

public class Explanation2 {
/*
 * [익명 구현 객체]
 * - 명시적인 구현 클래스 작성(소스파일 생성 , 그 안에 클래스를 명시적으로 선언하는 것)을 생략하고 
 * 		바로 구현 객체를 얻는 방법
 * 	-> 이름이 없는 구현 클래스 선언과 동시에 객체를 생성한다.
 * ex. 익명구현객체 생성 코드
	 * 인터페이스 변수 = new 인터페이스(){	-> '{}안처럼 이름없는 클래스를 생성하겠다'
	 * 									->	저생성자꼴은 인터페이스 생성자가 아니라 
	 * 										{}안에 선언된 클래스의 생성자를 호출하겠다는 뜻
	 * //인터페이스에 선언된 추상 메소드의 실체 메소드 선언
	 * };
 * 
 * - {}안에는 인터페이스의 추상 메소드들을 모두 재정의하는 실체 메소드가 있어야한다
 * 	 -> 인터페이스에 3개의 추상메소드가 있다면, {}내에도 실행내용을 가진 3개의 메소드를 선언해야만함 
 * - 추가적으로 필드와 메소드를 선언할 수 있지만 익명 객체 안에서만 사용할수있고,
 * 		인터페이스 변수로 접근할 수 없다
 * 	 -> {}내에서 따로 선언된 멤버들은 인터페이스에 선언된게 아니기때문에 {}밖에선 못쓴다
 * 
 * [주로 사용되는 곳]
 * - UI프로그래밍(Java Fx, Swing, Android)에서 이벤트를 처리하기 위해 주로 사용
 * - 임시 작업 스레드를 만들기 위해 사용
 * - 자바8부터 지원하는 람다식은 내부적으로 익명 구현 객체를 사용
 * 
 * [익명 구현 객체도 클래스(바이트코드) 파일을 가지고 있다.]
 * - 클래스 $번호.class 파일명으로 생성된다
 * 	-> 익명 구현 객체의 수에 맞게 번호가 올라감
 * 	-> 네비게이터 창에서 확인 가능
 * 
 * 
 * ----------------------------------------------------------------------
 * 
 * [다중 인터페이스 구현 클래스]
 * 
 * 
 * public class 구현클래스명 implement 인터페이스A, 인터페이스B{
 * 		-> A인터페이스로 '구현클래스명' 객체를 사용할 수 있고,
 * 			B인터페이스로도 '구현클래스명' 객체를 사용할 수 있고,
 * 		-> A,B가 가지고 있는 모든 추상메소드를 재정의해서 실체 클래스로 가지고 있어야한다
 * 	//인터페이스A에 선언된 추상 메소드의 실체 메소드 선언
 * 	//인터페이스B에 선언된 추상 메소드의 실체 메소드 선언
 * }
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */
}
