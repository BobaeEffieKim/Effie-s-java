package practice0803_interface_implement;

public class Explanation {
/*
 * <<인터페이스 구현>>
 * [구현 객체와 구현 클래스]
 * - 인터페이스의 추상메소드에 대한 실체 메소드를 가진 객체 = 구현 객체
 * 	-> 인터페이스만을 가지고는 실제 동작을 구현해내지못함 
 * 	-> 인터페이스를 통해 객체를 사용하는거라서 그 객체가 있어야함 (인터페이스의 구현객체)
 * - 구현 객체를 생성하는 클래스 = 구현 클래스
 * 
 * 
 * [구현 클래스 선언]
 * - 자신의 객체가 인터페이스 타입으로 사용할 수 있음을 implements 키워드로 명시
 * public class 구현클래스명 implements 인터페이스명 {
 * 	//인터페이스에 선언된 추상 메소드의 실체 메소드 선언
 * }
 * 
 * 
 * [추상메소드의 실체메소드를 작성하는 방법]
 * - 메소드의 선언부가 정확히 일치해야한다
 * - 인터페이스의 모든 추상 메소드를 재정의하는 실체 메소드를 작성해야한다
 * 	-> 일부만 재정의할 경우, 추상 클래스로 선언해야하며 abstract키워드가 붙어야한다
 * public abstract class Television implements RemoteControl{
 * 	public void turnOn(){}
 * 	public void turnOff(){}
 * 		//setVolume()메소드가 오버라이딩되지않음(일부만 구현됨)
 * 			-> !!그럼 이 클래스는 추상(abstract 붙여야함)클래스가 되어야만함!!
 * }
 * - 인터페이스의 모든 메소드는 public 접근제한을 갖기때문에 public보다 더 낮은 접근제한으로 작성할 수없다
 * 		-> private 이나 protected 안됨
 * - 이클립스의 자동생성기능을 이용한다
 * - @Override 어노테이션을 이용해서 정확히 재정의되었는지 컴파일러가 체크하도록 한다
 * 
 * 
 * -------------------------------------------------------------------
 * [인터페이스 변수와 구현 객체]
 * - 인터페이스를 사용하지 않은 경우
 * Television tv = new Television();
 * 
 * - 인터페이스를 사용한 경우
 * 인터페이스 변수 = 구현객체;
 * 	-> 인터페이스 변수 선언 후에 구현객체를 이 변수에 대입하여 인터페이스로서 구현객체 사용가능
 * 
 * 인터페이스 변수;
 * 변수 = 구현객체;	-> 이것도 동일
 * 
 * RemoteControl rc;	-> 변수 선언
 * rc = new Television();	-> 대입 => !!인터페이스를 구현한 클래스만 올 수 있음!!
 * rc = new Audio();		-> 대입
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */
}
