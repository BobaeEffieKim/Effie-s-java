package practice_0707_promotion;

public class Explanation {
/*
 * [다형성]
 * -같은 타입이지만 실행 결과가 다양한 객체를 대입(이용)할 수 있는 성질을 말한다.
 * -하나의 타입에 종류가 다른 다양한 객체를 대입할 수 있는것
 * 	-> 부모 타입에는 모든 자식 객체가 대입될 수 있다.
 * 		-> 자식 타입은 부모 타입으로 자동 타입 변환된다
 * 	-> 예) A(부모=종류), B(자식), C(자식)
 * 		A a = new B(); => a상속받았기때문에 a로 타입변환 된다
 * 		A a = new C();
 * 
 * 
 * -효과 : 객체를 부품화시킬 수 있다
 * 
 * 	=> 다형성은 객체를 부품화 시킨다
 * 	=> 자동차는 타이어 타입(부모)으로 한국 타이어(객체)와 금호 타이어(객체)를 
 * 		장착하여(대입) 사용하지만
 * 		각 타이어의 성능은 다르게 나온다 (다형성)
 * 	=> 한국타이어 사용하다 펑크나면 그 자리에 금호타이어를 넣을 수 있다.
 * 		-> 부품을 사용하다 문제가 생기면 다른 부품으로 교체 가능
 * 
 * ------------------------------------------------------
 * 
 * [자동 타입 변환] -> 참조타입일경우에 자동타입변환
 * - 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것
 * 
 *		부모클래스 변수 = 자식클래스타입;
 * 		->부모클래스 변수에 자식클래스타입의 객체를 대입하면 자동으로 타입변환 일어남
 * 
 * class Animal{
 * }
 * ↑(상속)
 * class Cat extends Animal{
 * }
 * 
 * 
 * Cat cat = new Cat();
 * Animal animal = cat;		->  cat객체가 애니멀 타입으로 변환된다
 * 	//Animal animal = new Cat(); 도 가능
 * 
 * cat == animal => true	->cat과 animal이 참조하는 변수가 같다
 * -> 자식객체가 부모타입으로 변환되었을때도, 여전히 같은 객체를 참조하지만 그냥 타입만 부모타입으로 변환됐을뿐이다
 * 
 * 
 * 	/상속계층에서 어떤 상위 타입이라도 자동 타입변환이 일어날 수있다.
 * 
 * 	A
 * ↑ ↑
 * B C
 * ↑ ↑
 * D E
 * 
 * B b = new B();
 * C c = new C();
 * D d = new D();
 * E e = new E();
 * 
 * A a1 = b; /가능
 * A a2 = c; /가능
 * A a3 = d; /가능
 * A a4 = e; /가능	//모든 객체가 A 상속 받았기때문
 * 
 * B b1 = d; /가능	//D는 B를 상속받았기때문
 * C c1 = e; /가능	//E는 C를 상속받았기때문
 * 
 * B b3 = e; /불가능	//전혀 상속 관계에 없기때문
 * C c2 = d; /불가능	//전혀 상속 관계에 없기때문
 * 
 * 
 *---------------------------------------------------------- 
 * [자동 타입 변한된 이후의 효과]
 * - 부모 클래스에 선언된 필드와 메소드만 접근가능
 * - 메소드가 재정의되었다면 자식클래스의 재정의된 메소드가 호출됨 (다형성관련)
 * 
 * class Parent{
 * 	void method1(){}
 * 	void method2(){}
 * }
 * 	↑(상속)
 * class Child extends Parent{
 * 	void method2(){}	//Overriding
 * 	void method3(){}
 * }
 * 
 * 
 * class ChildEx{
 * 	public static void main~~{
 * 	Child child = new Child();	//자식객체 생성(부모 객체도 자동으로 만들어짐->상속특징)
 * 
 * 	Parent parent = child;
 * 
 * 	parent.method1();
 * 
 * 	parent.method2();	=>method2호출하면 자식클래스에서 오버라이드한 것이 호출됨
 * 						=>(!!중요!!)차일드를 패런트로 타입변환만 한것일뿐, 자식객체가 없어지는것이 아님
 * 						따라서 부모클래스에도 있지만, 자식클래스에서 재정의된 메서드2가 호출됨 
 * 
 * 	parent.method3();	//호출불가-> 부모 클래스에는 메소드3이 없어서
 *  }
 * }
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */
}
